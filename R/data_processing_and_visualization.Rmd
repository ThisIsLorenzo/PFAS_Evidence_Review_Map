---
title: "Code_pilot"
author: "L. Ricolfi"
date: "25/11/2022"
output:
  html_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

In this Rmarkdown document I provide the workflow and code for the 3 objects of my Evidence Review Map and Bibliometric analysis (Chapter 1 of my thesis)

# Information on the project and its objectives

Project title: PFAS exposure of humans, animals and environmental compartments: an evidence review map and bibliometric analysis

-   **Objective 1. Mapping: What evidence on PFAS has been synthesized?** I aim to reveal what areas in the realm of PFAS health-related and environmental research have been synthesized the most and where syntheses of evidence are lacking.

-   **Objective 2. Critical appraisal: How robust are syntheses of PFAS evidence?** I will examine the included syntheses for their reporting quality and potential biases, in order to assess reliability of reviews' conclusions, reveal syntheses that should be re-done, and highlight the aspects of review methodology that need to be improved.

-   **Objective 3. Bibliometrics: How is synthesized PFAS evidence connected?** I will examine which countries and institutions are mostly involved in secondary PFAS research and what do the networks between these institutions look like.

**Note:** The code and all created outputs are based on a pilot set of data extracted from only 8 papers that fulfilled our inclusion criteria during the piloting stage.

## Setup

Set global code chunk parameters and load packages.

```{r setup, include = TRUE}

knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE)

pacman::p_load(tidyverse,
               here,
               stringr,
               knitr,
               formatR,
               forcats,
               ggplot2,
               hrbrthemes,#for ggplot2
               patchwork, #for ggplot2
               bibliometrix,
               igraph,
               xtable,
               kableExtra,
               rotl)
```

## Load pilot data

Manually extracted pilot data is stored in four separate **.csv** files representing different aspects of the data (extracted via structured predefined Google Forms - one per table). Additional fixed table stores pre-extracted data on PFAS types included in this map.

Bibliographic data records are exported from Scopus (including cited references field) in .bib format and locally saved as **scopus.bib** and **scopus2.bib**.

```{r load bibliometric data, eval=FALSE}
#Bibliometric data of included papers (with references) dwonloaded from Scopus in .bib format:
bib_sco <- convert2df(here("data","scopus.bib"), dbsource = "scopus", format = "bibtex")
#dim(bib_sco) #167 rows 33 columns

#Extra four studies founded searching on Scopus using the DOIs:
bib_sco2 <- convert2df(here("data","scopus2.bib"), dbsource = "scopus", format = "bibtex")
#dim(bib_sco2) #4 rows 32 columns

#Merging the two .bib files:
bib_data <- 
  bind_rows(bib_sco, bib_sco2)
#dim(bib_sco3) #171 rows 33 columns

bib_data <- metaTagExtraction(bib_data, Field = "AU1_CO",
                          sep = ";")

bib_data <- metaTagExtraction(bib_data, Field = "AU_CO", sep = ";")

#Save the combined bibliometric data
write.csv(bib_data, file = "~/PhD/GitHub/PFAS_Systematic_MetaReview_Map/data/bib_data.csv")
```

```{r load all data}
# Data from .csv file - main data sheet
mdata <- read_csv(here("data","ReviewMap_PFAS_main.csv"), skip = 0)
#dim(mdata) #175 rows 38 columns

# Data from .csv file - Species_info sheet
spdata <- read_csv(here("data","ReviewMap_PFAS_species.csv"), skip = 0) 
#dim(spdata) #145 rows 5 columns

# Data from .csv file - PFAS_types sheet:
ptdata <- read_csv(here("data","ReviewMap_PFAS_types.csv"), skip = 0) 
#dim(ptdata) #145 rows 5 columns
# change to long format (one type per row - one or multiple rows per study):
ptdata <- ptdata %>% separate_rows(PFAS_type, sep=', ')
#dim(ptdata) #608 rows 5 columns

# Data from .csv file - PFAS_info sheet:
pidata <- read_csv(here("data","PFAS_info.csv"), skip = 0) 
#dim(pidata) #35 rows 7 columns

# Critical apprisal(AMSTAR2) from .csv file:
qdata <- read_csv(here("data", "ReviewMap_PFAS_quality.csv"), skip = 0)
#dim(qdata) #107 rows 36 columns

#Combined bibliometric data
bib_data <- read_csv(here("data", "bib_data.csv"), skip = 0)
```

## Merge data stored across tables

The data stored across multiple flat spreadsheets needs merged for some of the analyses.

```{r merge data}

# Remove columns ending with "checked" 
# Remove "Timestamp" columns
# Remove columns starting with "Initials"
mdata <- 
  mdata %>%
  select(-ends_with("checked")) %>%
  select(-("Timestamp")) %>%
  select(-starts_with("Initials"))
#dim(mdata) #175 rows 35 columns
#remove last two rows because empty
mdata <- 
  mdata %>%
  drop_na(Author_year)
#dim(mdata) #173 rows 35 columns
spdata <- 
  spdata %>%
  select(-ends_with("checked"))
#dim(spdata) #145 rows 5 columns
ptdata <- 
  ptdata %>%
  select(-ends_with("checked")) %>%
  select(-("Timestamp")) %>%
  select(-starts_with("Initials"))
#dim(ptdata) #608 rows 3 columns

## Merge main data with species info
mspdata <- left_join(mdata, spdata, by = "Study_ID")
#dim(mspdata) #579 rows 38 columns
#names(mspdata)
#str(mspdata)
#View(mspdata)

# Merge PFAS types data with PFAS info and then with main data
ptidata <- left_join(ptdata, pidata, by = "PFAS_type")
#dim(ptidata) #174 rows 9 columns
#names(ptidata)
#str(ptidata)
#View(ptidata)

mpidata <- left_join(mdata, ptidata, by = "Study_ID")
#dim(mpidata) #176 rows 43 columns
#names(mpidata)
#str(mpidata)
#View(mpidata)

```

## Make a simple summary table of included papers

```{r simple table of included studies}
#First, order the table by Study_ID
mdata <- 
  mdata[order(mdata$Study_ID),]

knitr::kable(select(mdata, Study_ID,	Author_year,	Paper_title), caption = "Table of included studies") %>%
  kable_paper(bootstrap_options = "striped", full_width = F) #%>% save_kable(file = "table1.html", self_contained = T)

```

# -----------------------------------------------------------------------

## Objective 1. Mapping: What evidence on PFAS has been synthesized?

Here we aim to reveal what areas in the realm of PFAS health-related and environmental research have been synthesized the most and where syntheses of evidence are lacking.

### Focus on PFAS, or POPs, and how many PFAS

```{r PFAS focus one_many barplot, height = 2, width = 8}
#str(mdata)
t_PFASfocus <-
  mdata %>%
  count(PFAS_focus, PFAS_one_many) %>%
  arrange(desc(n)) %>% 
  filter(PFAS_focus != "NA") #filter out NA

#Use a colorblind-friendly palette:
cbp1 <- c("#56B4E9",
          "#E69F00",
          "#999999")

PFAS_focus <-
  ggplot(t_PFASfocus, aes(x = PFAS_focus, 
                          y = n)) +
  theme_light() +
  labs(title = expression("Is the review focused on PFAS?")) + #~bold(A.)~' Type and subject'
  coord_flip() +
  scale_fill_brewer() +
  guides(fill=guide_legend(title="How many PFAS types:")) + 
  geom_col(aes(fill = fct_relevel(PFAS_one_many, c("Not specified",
                                                   "Multiple",
                                                   "One"))), width = 0.5) + 
  scale_y_continuous(name = "Article count") +
  scale_fill_manual(values=cbp1, breaks=c('One', 
                                          'Multiple',
                                          'Not specified')) +
  theme_light() +
  theme(legend.position = "bottom",
       legend.box.background = element_rect(colour = "black"), 
       legend.title = element_text(size=10),
       legend.text = element_text(size = 10), 
       axis.title.x = element_text(size = 10),
       axis.title.y = element_blank(),
       legend.background = element_blank())

PFAS_focus

#ggsave(here("plots","figure_PFAS_focus.pdf"), width = 4, height = 6, units = "cm", scale = 2, device = cairo_pdf)

```

```{r, eval=FALSE}
count(mdata, PFAS_focus)
# A tibble: 2 × 2
#   PFAS_focus     n
#   <chr>      <int>
# 1 No            90
# 2 Yes           83
count(mdata, PFAS_one_many)
# A tibble: 3 × 2
#   PFAS_one_many     n
#   <chr>         <int>
# 1 Multiple        102
# 2 Not specified    45
# 3 One              26
```


### PFAS types

```{r plot PFAS types barplot, height = 8, width = 8}

#str(ptidata)
t_PFAStype <- ptidata %>%
  count(PFAS_type) %>%
  arrange(desc(n)) %>%
  filter(PFAS_type != "NA") #filter out NA

t_PFAStype$PFAS_type <-
  factor(t_PFAStype$PFAS_type, levels = t_PFAStype$PFAS_type[order(t_PFAStype$n, decreasing = FALSE)])

PFAS_levels_order <-
  t_PFAStype$PFAS_type[order(t_PFAStype$n, decreasing = FALSE)] #save for another plot

# simple barplot with PFAS types
PFAS_types <- ggplot(t_PFAStype, aes(x = PFAS_type,
                       y = n)) +
  geom_col(aes(fill = ""), width = 0.7) +
  theme_light() +
  labs(title = expression("PFAS types reviewed")) + #~bold(A.)~' Type and subject'
  coord_flip()+
  scale_y_continuous(name = "Article count") +
  scale_fill_manual(values = c("#919191")) +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11),
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = 7))

PFAS_types

#ggsave(here("plots","figure_PFAS_types.pdf"), width = 4, height = 6, units = "cm", scale = 2, device = cairo_pdf)
```

```{r, eval=FALSE}
ptidata_counts <- ptidata %>% count(PFAS_type)
ptidata_counts <- ptidata_counts %>% arrange(desc(n))
ptidata_counts
# A tibble: 29 × 2
#    PFAS_type     n
#    <chr>     <int>
#  1 PFOA         81
#  2 PFOS         75
#  3 PFHxS        49
#  4 PFNA         48
#  5 PFDA         39
#  6 PFUnDA       34
#  7 PFDoDA       31
#  8 PFBS         27
#  9 PFHxA        27
# 10 PFHpA        24
```

```{r, circular barplot, eval = FALSE}
# Get the name and the y position of each label
label_data <- t_PFAStype %>% 
  mutate(id = seq(1,29))
# calculate the ANGLE of the labels
number_of_bar <- nrow(label_data)
angle <-  90 - 360 * (label_data$id-0.5) /number_of_bar
# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
label_data$hjust<-ifelse( angle < -90, 1, 0)
# flip angle BY to make them readable
label_data$angle<-ifelse(angle < -90, angle+180, angle)

# Start the plot
p <- ggplot(label_data, aes(x= as.factor(id), y=n)) +       # Note that id is a factor. If x is numeric, there is some space between the first bar

# This add the bars with a blue color
geom_bar(stat="identity", fill=alpha("skyblue", 0.8)) +
# Limits of the plot = very important. The negative value controls the size of the inner circle, the positive one is useful to add size over each bar
  ylim(-80,120) +
  
  # Custom the theme: no axis title and no cartesian grid
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm")      # Adjust the margin to make in sort labels are not truncated!
  ) +
  
  # This makes the coordinate polar instead of cartesian.
  coord_polar(start = 0) +
  
  # Add the labels, using the label_data dataframe that we have created before
  geom_text(data=label_data, aes(x=id,
                                y=n,
                                label=PFAS_type,
                                hjust=hjust),
            color="black",
            fontface="plain",
            alpha=0.8,
            size=3.5,
            angle= label_data$angle,
            inherit.aes = FALSE )
 
p
```


### Main review topics (MeSH terms)

Each records usually has multiple associated MeSH terms, which are separated with a semicolon (or a semicolon with a newline symbol).\
The main topics of the article are denoted by the MeSH terms with asterisks \*, but some records will not have main topics, so its safer to ignore this information.\
Some MeSH headings also have qualifiers (sometimes called subheadings) - these are shown after a forward-slash and are used to "describe the specific aspects of the MeSH heading that are pertinent to the article" (<https://www.nlm.nih.gov/bsd/indexing/training/SUB_010.html>). MeSH terms and qualifiers could be analysed separately.

```{r plot main topics barplot prep, height = 4, width = 8}

# change to long format (one species per row - one or multple rows per study):
t_MESH <-
  mdata %>%
  select(MeSH_terms) %>%
  separate_rows(MeSH_terms, sep = ";\\\n") %>%
  separate_rows(MeSH_terms, sep = "; ")
#bring to lower case and remove ending and trailing whitespace from character strings, single character vector:
tmesh <- 
  str_to_lower(trimws(t_MESH$MeSH_terms)) 
#remove star character:
tmesh <- 
  sub("[\\*]", "", tmesh) 

#separate terms before and after "/" into separate columns (headings and quantifiers, respectively)
tmesh2 <- 
  str_split_fixed(tmesh, " / ", n = 2)

#create a MeSH dataframe with three columns: terms, headings, qualifiers
t_MESH2 <- 
  bind_cols(tmesh, tmesh2[,1], tmesh2[,2])

colnames(t_MESH2) <- c("MeSH_terms",
                       "MeSH_headings",
                       "MeSH_qualifiers")

```

```{r plot MeSH headings barplot, height = 4, width = 8}

#count frequencies of headings
MeSH_headings_counts <- t_MESH2 %>%
  select(MeSH_headings) %>%
  count(MeSH_headings) %>%
  arrange(desc(n)) %>% 
  filter(MeSH_headings != "NA") %>%
  filter(MeSH_headings != "")
#str(MeSH_headings_counts)

MeSH_headings_counts$MeSH_headings <- 
  factor(MeSH_headings_counts$MeSH_headings, levels = MeSH_headings_counts$MeSH_headings[order(MeSH_headings_counts$n, decreasing = FALSE)])

MESH_headings_order <- 
  MeSH_headings_counts$MeSH_headings[order(MeSH_headings_counts$n, decreasing = FALSE)] #save for the next plot

# simple barplot with top 10 MESH headings
ggplot(MeSH_headings_counts[1:10, ], aes(x = MeSH_headings, y = n)) +
  geom_col(aes(fill = ""), width = 0.7) +
  theme_light() +
  labs(title = expression("Top 10 MeSH headings reviewed")) + #~bold(A.)~' Type and subject'
  coord_flip() +
  scale_y_continuous(name = "Article count") +
  scale_fill_manual(values = c("#919191")) +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 13),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 10))

#ggsave(here("plots","figure_MeSH_headings.pdf"), width = 4, height = 6, units = "cm", scale = 2, device = cairo_pdf)
```

```{r plot MeSH qualifiers barplot, height = 4, width = 8}

#count frequencies of qualifiers
MeSH_qualifiers_counts <- t_MESH2 %>%
  select(MeSH_qualifiers) %>%
  count(MeSH_qualifiers) %>%
  arrange(desc(n)) %>%
  filter(MeSH_qualifiers != "NA") %>%
  filter(MeSH_qualifiers != "")
#str(MeSH_qualifiers_counts)

MeSH_qualifiers_counts$MeSH_qualifiers <- 
  factor(MeSH_qualifiers_counts$MeSH_qualifiers, levels = MeSH_qualifiers_counts$MeSH_qualifiers[order(MeSH_qualifiers_counts$n, decreasing = FALSE)])

MESH_qualifiers_order <- 
  MeSH_qualifiers_counts$MeSH_qualifiers[order(MeSH_qualifiers_counts$n, decreasing = FALSE)] #save for the next plot

# simple barplot with MESH qualifiers
ggplot(MeSH_qualifiers_counts[, ], aes(x = MeSH_qualifiers,
                                       y = n)) +
  geom_col(aes(fill = ""), 
           width = 0.9,
           position = 'dodge') +
  theme_light() +
  labs(title = expression("MeSH qualifiers reviewed")) + #~bold(A.)~' Type and subject'
  coord_flip() +
  scale_y_continuous(name = "Article count",
                     expand = c(0,0)) +
  scale_fill_manual(values = c("#919191")) +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 13),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 10))
#ggsave(here("plots","figure_MeSH_qualifiers.pdf"), width = 4, height = 6, units = "cm", scale = 2, device = cairo_pdf)
```

```{r, eval=FALSE}
MeSH_qualifiers_counts
# A tibble: 36 × 2
#    MeSH_qualifiers        n
#    <fct>              <int>
#  1 toxicity             168
#  2 analysis             114
#  3 adverse effects       73
#  4 drug effects          63
#  5 chemically induced    52
#  6 epidemiology          46
#  7 metabolism            42
#  8 chemistry             30
#  9 etiology              17
# 10 blood                 14
# … with 26 more rows
# ℹ Use `print(n = ...)` to see more rows
```


### Main review subjects

```{r plot main subjects barplot, height = 2, width = 8}

#str(mdata)
t_subject <- mdata %>%
  count(Human_animal_environment) %>%
  arrange(desc(n)) %>% 
  filter(Human_animal_environment != "NA") %>%
  filter(Human_animal_environment != "") #filter out NA

t_subject$Human_animal_environment <-
  factor(t_subject$Human_animal_environment, levels = unique(t_subject$Human_animal_environment[order(t_subject$n, decreasing = FALSE)]))

subjects_levels_order <- 
  t_subject$Human_animal_environment[order(t_subject$n, decreasing = FALSE)] #save for another plot

# simple barplot with MESH_heading
ggplot(t_subject, aes(x = Human_animal_environment, y = n)) +
  geom_col(aes(fill = ""), width = 0.7) +
  theme_light() +
  labs(title = expression("Main subjects reviewed")) + #~bold(A.)~' Type and subject'
  coord_flip()+
  scale_y_continuous(name = "Article count",
                     expand = c(0,0)) +
  scale_fill_manual(values = c("#919191")) +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 10),
        axis.title.y = element_blank(),
        axis.text = element_text(size = 10))

#ggsave(here("plots","figure_subjects.pdf"), width = 4, height = 2, units = "cm", scale = 2, device = cairo_pdf)
```

```{r}
count(mdata, Human_animal_environment)
# A tibble: 5 × 2
#   Human_animal_environment     n
#   <chr>                    <int>
# 1 Animals                     12
# 2 Environment                 23
# 3 Humans                     118
# 4 Mixed                       17
# 5 Plants                       3
```


### Combining MeSH qualifiers with main review subjects

```{r plot MeSH qualifiers with main review subjects barplot, height = 4, width = 8}

#str(mdata)
#subset main dat by main subject
#table(mdata$Human_animal_environment)

# change to long format (one species per row - one or multple rows per study):
t_MESHby <- mdata %>%
  group_by(Human_animal_environment) %>%
  select(MeSH_terms) %>% 
  separate_rows(MeSH_terms, sep = ";\\\n") %>%
  separate_rows(MeSH_terms, sep = "; ")
#str(t_MESHby)

tmeshby <- 
  str_to_lower(trimws(t_MESHby$MeSH_terms)) #bring to lower case and remove ending and trailing whitespace from character strings, single character vector
tmeshby <- 
  sub("[\\*]", "", tmeshby) #remove star character

#separate terms before and after "/" into separate columns (headings and quantifiers, respectively)
tmeshby2 <- 
  str_split_fixed(tmeshby, " / ", n = 2)

#create a MeSH dataframe with three columns: terms, headings, qualifiers
t_MESHby2 <-
  bind_cols(t_MESHby$Human_animal_environment,
            tmeshby, 
            tmeshby2[,1], 
            tmeshby2[,2])

colnames(t_MESHby2) <-
  c("Subject", 
    "MeSH_terms", 
    "MeSH_headings", 
    "MeSH_qualifiers")
#str(t_MESHby2)

t_topic_subject <-
  t_MESHby2 %>%
  count(MeSH_qualifiers, Subject) %>%
  arrange(desc(n)) %>%
  filter(MeSH_qualifiers != "NA") %>% 
  filter(MeSH_qualifiers != "") #filter out NA

t_topic_subject$Subject <-
  factor(t_topic_subject$Subject, 
         levels = subjects_levels_order) #use order from the previous graph

t_topic_subject$MeSH_qualifiers <-
  factor(t_topic_subject$MeSH_qualifiers, 
         levels = MESH_qualifiers_order) #use order from the previous graph
#str(t_topic_subject)

#Set palette
cbp2 <- c("#56B4E9",
          "#E69F00",
          "#F0E442",
          "#009E73",
          "#999999",
          "#0072B2",
          "#D55E00",
          "#CC79A7")

ggplot(t_topic_subject, aes(x = MeSH_qualifiers, 
                            y = n)) +
 theme_light() +
 labs(title = expression("MeSH qualifiers and subjects reviewed")) + #~bold(A.)~' Type and subject'
 coord_flip()  +
 scale_fill_brewer() +
 geom_col(aes(fill = fct_relevel(Subject, c("Mixed", 
                                            "Plants", 
                                            "Environment", 
                                            "Animals", 
                                            "Humans"))), width = 0.7) + 
  scale_fill_manual(values=cbp2,
                     breaks=c("Humans", 
                              "Animals", 
                              "Environment", 
                              "Plants", 
                              "Mixed")) +
  scale_y_continuous(name = "Article count",
                     expand = c(0,0)) +
 theme_light() +
 theme(legend.position = c(0.7, 0.5),
       legend.box.background = element_rect(colour = "black"),
       legend.title = element_blank(),
       legend.text = element_text(size = 13),
       axis.title.x = element_text(size = 15),
       axis.title.y = element_blank(),
       axis.text = element_text(size = 8),
       legend.background = element_blank())

#ggsave(here("plots","figure_MeSH_qualifiers_subjects.pdf"), width = 4, height = 6, units = "cm", scale = 2, device = cairo_pdf)

```

```{r}
view(t_topic_subject)
```


### PFAS focus by main review subject

```{r plot PFAS focus by Human_animal_environment barplot, height = 2, width = 8}
# PFAS_one_many vs. Human_animal_environment contingency table
t1 <-
  mdata %>%
  count(Human_animal_environment, PFAS_one_many)

ggplot(t1, aes(x = PFAS_one_many ,
               y = n)) +
 coord_flip()  +
  theme_light() +
 labs(title = expression("PFAS focus and subjects reviewed")) +
 geom_col(aes(fill = fct_relevel(Human_animal_environment, c("Mixed",
                                                             "Plants",
                                                             "Environment",
                                                             "Animals", 
                                                             "Humans"))),
          width = 0.7) +
  #geom_text(aes(label = n), position = position_stack(vjust = 0.2)) +
  scale_fill_manual(values=cbp2,
                    breaks=c("Humans", 
                             "Animals",
                             "Environment", 
                             "Plants", 
                             "Mixed")) +
 theme_light() +  
 theme(legend.position = "bottom",
       legend.box.background = element_rect(colour = "black"),
       legend.title = element_blank(),
       legend.text = element_text(size = 12),
       axis.title.x = element_text(size = 10),
       axis.title.y = element_blank(),
       axis.text = element_text(size = 10),
       legend.background = element_blank()) +
 ylab("Article count") +
  scale_y_continuous(name = "Article count",
                     expand = c(0,0)) +
 guides(fill=guide_legend(title="Subject:")) 

#ggsave(here("plots","figure_PFAS_focus_subjects.pdf"), width = 4, height = 2, units = "cm", scale = 2, device = cairo_pdf)

```

### PFAS types by main review subject

```{r plot PFAS types by Human_animal_environment barplot, height = 8, width = 8}

#str(mpidata)
t_PFAStype <-
  mpidata %>%
  count(PFAS_type, Human_animal_environment) %>%
  arrange(desc(n)) %>%
  filter(PFAS_type != "NA") #filter out NA
#t_PFAStype$PFAS_type <- factor(t_PFAStype$PFAS_type, levels = unique(t_PFAStype$PFAS_type[order(t_PFAStype$n, decreasing = FALSE)]))
t_PFAStype$PFAS_type <-
  factor(t_PFAStype$PFAS_type, levels = PFAS_levels_order) #use order from the previous graph


p_PFAStype <-
  ggplot(t_PFAStype, aes(x = PFAS_type,
                         y = n)) +
  theme_light() +
  labs(title = expression("PFAS type and main subjects reviewed")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  scale_fill_brewer() +
  geom_col(aes(fill = fct_relevel(Human_animal_environment, c("Mixed",
                                                              "Plants",
                                                              "Environment",
                                                              "Animals",
                                                              "Humans"))), width = 0.7) +
  scale_fill_manual(values=cbp2,
                    breaks=c("Humans",
                             "Animals",
                             "Environment",
                             "Plants", 
                             "Mixed")) +
  scale_y_continuous(name = "Article count",
                     expand = c(0,0)) +
  theme(legend.position = c(0.6, 0.5),
       legend.box.background = element_rect(colour = "black"),
       legend.title = element_blank(),
       legend.text=element_text(size = 13),
       title = element_text(size = 14),
       axis.title.x = element_text(size = 15),
       axis.title.y = element_blank(),
       legend.background = element_blank())
#theme(legend.position = "none", axis.title.x = element_text(size = 10), axis.title.y = element_blank())
p_PFAStype

#ggsave(here("plots","figure_PFAStype_subject.pdf"), width = 6, height = 8, units = "cm", scale = 2, device = cairo_pdf)

```

### Species tree

Species tree in "species_tree.Rmd"

### Time-trends

```{r area plots year, height = 2, width = 8}

publ_year <- mdata %>%
  count(Publication_year) %>%
  ggplot(aes(x = Publication_year,
             y = n)) + 
  geom_area(fill = '#69b3a2', 
            alpha = 0.5) +
  geom_line(color = '#69b3a2', 
            size = 1) + 
  #geom_point(size = 0.8, color = 'black') +
  #theme_minimal() +
  scale_x_continuous(name = "Year",
                     breaks = seq(2008, 2022, by = 2),
                     minor_breaks = NULL) +
  scale_y_continuous(name = "Number of published reviews",
                    breaks = seq(0, 50, by = 10),
                    minor_breaks = NULL
                    ) +
  ggtitle("Publication year") + 
  theme_ipsum(grid_col = "#F5F5F5") +
  ylab("Number of published reviews") +
  theme(plot.title = element_text(size = 26,
                                  hjust = 0.5),
       axis.text.x = element_text(size = 16,
                                  margin = margin(t = 1, 
                                                  r = 0,
                                                  l = 0)),
       axis.text.y = element_text(size = 16,
                                  margin = margin(t = 0, 
                                                  r = 5, 
                                                  l = 5)),
       axis.title.x = element_text(size = 20,
                                   hjust = 0.5),
       axis.title.y = element_text(size = 20,
                                   hjust = 0.5))
        #axis.title.y.right = element_text(size = 16, margin = margin(t = 0, r = 10, l = 10)))
  
publ_year
# ggsave(here("R","figure_area_publ_year.pdf"),
#        width = 10, 
#        height = 10, 
#        units = "cm", 
#        scale = 2,
#        device = cairo_pdf)

#modified graph with breakdown by Review_type_claimed (needs more data points to be displayed properly)
# mspdata %>%
#   count(Publication_year, 
#         Review_type_claimed) %>%
#   ggplot(aes(x = Publication_year,
#              y = n,
#              fill = Review_type_claimed,
#              text = Review_type_claimed)) +
#   geom_line(color = 'black')
#   
  

#modified graph with breakdown by Species_higher_taxon (needs more data points to be displayed properly)
#mspdata %>% count(Publication_year, Species_common_name) %>% ggplot(aes(x = Publication_year, y = n, fill = Species_common_name, text = Species_common_name)) + geom_area() + theme(legend.position = "right")

```

```{r}
count(mdata, Publication_year)
# A tibble: 15 × 2
#    Publication_year     n
#               <dbl> <int>
#  1             2008     2
#  2             2009     2
#  3             2011     4
#  4             2012     1
#  5             2013     9
#  6             2014     9
#  7             2015     5
#  8             2016    10
#  9             2017    18
# 10             2018    14
# 11             2019    16
# 12             2020    22
# 13             2021    48
# 14             2022    12
# 15               NA     1
```


# ------------------------------------------------------------------------

## Objective 2. Critical appraisal: How robust are syntheses of PFAS evidence?

Here we will examine the included syntheses for their reporting quality and potential biases, in order to assess reliability of reviews' conclusions, reveal syntheses that should be re-done, and highlight the aspects of review methodology that need to be improved.

## Make a table with AMSTAR2 questions

The questions were stored separately in the first row of the file, and were loaded separately. We display them in a table, alongside the short labels that can be used in the plots. Full description of the questions and coding rules (from an adapted AMSTAR2 checklist; Shea et al. 2017; Samarasinghe et al. 2019), are provided in the protocol.

```{r AMSTAR2 questions}
questions_list <- qdata %>% select(starts_with("Q") & !ends_with("_comment")) %>% colnames()  #only select columns with assessment codes (data)

questions <- tibble(questions = questions_list, label = c("question and criteria", "a priori protocol", "included study designs", "comprehensive search", "selection duplicated", "extraction duplicated", "list of excluded studies", "summary of included studies", "critical appraisal", "sources of funding", "quantitative synthesis", "risk of bias", "effect of bias", "variability investigated", "publication bias", "conflict of interest"))
#str(questions)

knitr::kable(questions, caption = "Table. List of AMSTAR2 questions with  labels for plotting")
```

## Summary plot for pilot AMSTAR2 data

AMSTAR2 assessment results as percentages of each answer score per question.

```{r plot AMSTAR2 summary}
## prepare data 
dim(qdata) #some empty rows to be removed

#studies <- qdata$Author_year #normally would use this

#only select columns with assessment codes (drop comments and empty rows)
qtable <- 
  qdata %>%
  filter(Study_ID!="NA") %>%
  select(starts_with("Q") & !ends_with("_Comment"))  

#simiplify column names to Q+number format
names(qtable) <- 
  gsub("\\..*", "", names(qtable)) 

#simplify all the answers to short strings (version for a single column: gsub(" =.*", "", qtable$Q1)):
qtable <- 
  apply(qtable, 2, function(y) as.character(gsub(" =.*", "", y)))

#save studies in a new vector
studies <- 
  qdata$Study_ID[!is.na(qdata$Study_ID)]

#convert to long format data frame with Study_ID
qtable_long <-
  data.frame(study = studies,
             question = rep(colnames(qtable),each = length(studies)),
             score = as.vector(qtable), stringsAsFactors = TRUE) #make long format table

rownames(qtable_long) <- NULL
qtable_long$question <- 
  factor(qtable_long$question, levels(qtable_long$question)[rev(c(1,9:16,2:8))]) #setting the order of levels - by Q-number

#add a column with verbal expression of scores:   
qtable_long$score_word <- qtable_long$score
levels(qtable_long$score_word) <- c("No", "Partially", "Yes", "Not Applicable")


summaryplot <-
  ggplot(data = qtable_long) +
  geom_bar(mapping = aes(x = question, fill = fct_relevel(score_word, c("Not Applicable", 
                                                                        "Partially", 
                                                                        "No", 
                                                                        "Yes"))), width = 0.7, position = "fill", color = "black") +
  coord_flip(ylim = c(0, 1)) +
  guides(fill = guide_legend(reverse = F)) +
  scale_fill_manual("Risk of Bias",
                        values=cbp2,
                        breaks=c("Yes",
                                 "No",
                                 "Partially", 
                                 "Not Applicable")) +
  scale_y_continuous(labels = scales::percent, expand = c(0.02,0)) +
  scale_x_discrete(expand = c(0.02,0)) +
  theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.text.x = element_text(size = 14, color = "black", hjust=0.5),
            axis.text.y = element_text(size = 14, color = "black", hjust=0),
            axis.line.x = element_line(colour = "black", size = 0.5, linetype = "solid"),
            legend.position = "bottom",
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            legend.background = element_rect(linetype = "solid", colour = "grey"),
            legend.title = element_blank(),
            legend.key.size = unit(0.75, "cm"),
            legend.text = element_text(size = 14))

# display plot
summaryplot

# save plot
#ggsave(here("plots","figure_AMSTAR2_summary_v01.pdf"), width = 10, height = 8, units = "cm", scale = 2, device = cairo_pdf)

```


## Individual scores plot for pilot AMSTAR2 data

AMSTAR2 assessment results as a score per article per question.

```{r AMSTAR2 scores}
## data prep
dim(qdata) #some empty rows to be removed

#save studies in a new vector
studies <- qdata$Study_ID[!is.na(qdata$Study_ID)]
#studies <- qdata$Author_year #normally would use this

#only select columns with assessment codes (drop comments and empty rows)
qtable <- qdata %>%
  filter(Study_ID!="NA") %>%
  select(starts_with("Q") & !ends_with("_comment")) 

#simiplify column names to Q+number format
names(qtable) <- gsub("\\..*", "", names(qtable)) 

#simplify all the answers to short strings (version for a single column: gsub(" =.*", "", qtable$Q1)):
qtable <- apply(qtable, 2, function(y) as.character(gsub(" =.*", "", y)))

## prepare data - change scores to verbal expressions: 
qtable <- gsub("N/A", "Not Applicable", qtable)
qtable <- gsub("0.5", "Partially", qtable)
qtable <- gsub("1", "Yes", qtable)
qtable <- gsub("0", "No", qtable)


#convert to long format data frame with Study_ID
qtable_long <- data.frame(study = as.factor(studies),
                     question = rep(colnames(qtable), each = length(studies)),
                     measurement = as.vector(qtable), stringsAsFactors=FALSE)

rownames(qtable_long) = NULL
qtable_long$question <- as.factor(qtable_long$question)
qtable_long$question <- factor(qtable_long$question, levels(qtable_long$question)[c(1,9:16,2:8)]) #setting the order of levels - by Q-number
qtable_long$study <- factor(qtable_long$study, levels = unique(studies)[rev(order(unique(qtable_long$study)))]) #Re-order by study name (alphabetically)

##Make scoreplot      
scoresplot <-
  ggplot(data = qtable_long, aes(y = study, x = question)) +
  geom_tile(color="black", fill="white", size = 1) +
  geom_point(aes(color=as.factor(measurement)), size=3) +
  #geom_text(aes(label = measurement), size = 8) +
  scale_color_manual(values=cbp2,
                     breaks=c("Yes", "No", "Partially", "Not Applicable"),
                     guide = guide_legend(override.aes = list(size = 6,
                                                               alpha = 1))) +
  theme_minimal() +
  coord_equal() +
        theme(axis.title.x = element_text(size = 14, color = "black", face = "italic"),
              axis.title.y = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_text(size = 12, color = "black"),
              axis.text.x = element_text(size = 10, color = "black", angle = 90, ),
              legend.position = "bottom",
              legend.background = element_rect(linetype = "solid", colour = "black"),
              legend.title = element_blank(),
              legend.key.size = unit(1, "cm"),
              legend.text = element_text(size = 14),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank()
              #plot.margin = unit(c(1,1,1,0), "cm") #set margins for saving into pdf file
      ) +
  coord_flip()
  
scoresplot
  
## save plot
#ggsave(here("plots","figure_AMSTAR2_scores_v01.pdf"), width = 16, height = 12, units = "cm", scale = 2, device = cairo_pdf)
```

```{r plot combine AMSTAR2, eval = FALSE, include = FALSE}
#Make a figure with two plots in one column and save to a pdf file

## combine plots
finalplot <- summaryplot + scoresplot + plot_layout(ncol = 1)
finalplot
## save combined figure
#ggsave(here("plots","figure_AMSTAR2_2plots_v01.pdf"), width = 10, height = 16, units = "cm", scale = 2, device = cairo_pdf)

```

### COI statement

Whether Conflict Of Interests statement is provided for individual reviews.

```{r COI_statement barplot, height = 2, width = 8}

t_COI_statement <-
  mdata %>%
  count(COI_statement) %>%
  arrange(desc(n)) %>%
  filter(COI_statement != "NA") #filter out NA

p1 <-
  ggplot(t_COI_statement, aes(x = COI_statement, y = n)) +
  labs(title = expression("COI statement availability")) + #~bold(A.)~' Type and subject'
  geom_col(aes(fill = fct_relevel(COI_statement,
                                  c("No", "Yes")),
                                  width = 0.7)) +
  scale_fill_manual(values = cbp1,
                    breaks = c("No", "Yes")) +
  scale_y_continuous(name = "Article count") +
  theme(legend.position = "none",
        axis.title.y = element_blank()) +
  theme_light() +
  coord_flip()
  
p1

```

### COI present

Whether potential Conflict Of Interests is acknowledged for individual reviews.

```{r COI_present barplot, height = 2, width = 8}

t_COI_present <- 
  mdata %>% 
  count(COI_present) %>% 
  arrange(desc(n)) %>% 
  filter(COI_present != "NA") #filter out NA

p2 <- 
  ggplot(t_COI_present, aes(x = COI_present, y = n)) +
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_blank()) +
  labs(title = expression("Conflict of Interest")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  geom_col(aes(fill = COI_present), width = 0.7) + 
  scale_y_continuous(name = "Article count")
p2
```

### Funding statement

Whether funding statement is provided for individual reviews.

```{r Funding_statement barplot, height = 2, width = 8}

t_Funding_statement <- mdata %>% 
  count(Funding_statement) %>% 
  arrange(desc(n)) %>% 
  filter(Funding_statement != "NA") #filter out NA

p3 <- 
  ggplot(t_Funding_statement, aes(x = Funding_statement, y = n)) +
  theme_light() +
  theme(legend.position = "none", axis.title.y = element_blank()) +
  labs(title = expression("Funding statement availability")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  geom_col(aes(fill = Funding_statement), width = 0.7) + 
  scale_y_continuous(name = "Article count")

p3
```

### Non-profit funding acknowledged

Whether funding from non-profit (NGO, government, universities, etc.) is acknowledged for individual reviews.

```{r t_Nonprofit_funding barplot, height = 2, width = 8}
mdata <- 
  mdata %>% 
  rename(Nonprofit_funding = "Non-profit_funding") 

t_Nonprofit_funding <- 
  mdata %>% 
  count(Nonprofit_funding) %>% 
  arrange(desc(n)) %>% 
  filter(Nonprofit_funding != "NA") #filter out NA

p4 <- 
  ggplot(t_Nonprofit_funding, aes(x = Nonprofit_funding, y = n)) +
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_blank()) +
  labs(title = expression("Non-profit funding")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  geom_col(aes(fill = Nonprofit_funding), width = 0.7) + 
  scale_y_continuous(name = "Article count")

```

### Industry funding acknowledged

Whether funding from industry (including government-industry collaborations) is acknowledged for individual reviews.

```{r Industry_funding barplot, height = 2, width = 8}

t_Funding_industry <- mdata %>% 
  count(Industry_funding) %>% 
  arrange(desc(n)) %>% 
  filter(Industry_funding != "NA") #filter out NA

p5 <- 
  ggplot(t_Funding_industry, aes(x = Industry_funding, y = n)) +
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_blank()) +
  labs(title = expression("Funding from industry")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  geom_col(aes(fill = Industry_funding), width = 0.7) + 
  scale_y_continuous(name = "Article count")
```

### Data availability

Whether extracted data is made available for individual reviews.

```{r Raw_data barplot, height = 2, width = 8}
#str(mdata)
t_Raw_data <- 
  mdata %>% 
  count(Raw_data) %>% 
  arrange(desc(n)) %>% 
  filter(Raw_data != "NA") #filter out NA

p6 <- ggplot(t_Raw_data, aes(x = Raw_data, y = n)) +
 theme_light() +
 theme(legend.position = "none",
       axis.title.y = element_blank()) +
 labs(title = expression("Data availability")) + #~bold(A.)~' Type and subject'
 coord_flip()  +
 geom_col(aes(fill = Raw_data), width = 0.7) + 
 scale_y_continuous(name = "Article count")

#ggsave(here("plots","figure_data_availability.pdf"), width = 4, height = 3, units = "cm", scale = 2, device = cairo_pdf)

```

### Code availability

Whether code for analyses is made available for individual reviews.

```{r Analysis_code barplot, height = 2, width = 8}

t_Analysis_code <- 
  mdata %>% 
  count(Analysis_code) %>% 
  arrange(desc(n)) %>% 
  filter(Analysis_code != "NA") #filter out NA

p7 <- ggplot(t_Analysis_code, aes(x = Analysis_code, y = n)) +
 theme_light() +
 theme(legend.position = "none",
       axis.title.y = element_blank()) +
 labs(title = expression("Analysis code availability")) + #~bold(A.)~' Type and subject'
 coord_flip()  +
 geom_col(aes(fill = Analysis_code), width = 0.7) + 
 scale_y_continuous(name = "Article count")

```

### Plots combined - COI

```{r, plots combined 1}
(p1+p2)
```

### Plots combined - Funding

```{r, plots combined 2}
(p3)/(p4+p5)
```

### Plots combined - Data and Code availability

```{r, plots combined 3}
(p6+p7)
```

# ------------------------------------------------------------------------

## Objective 3. Bibliometrics: How is synthesized PFAS evidence connected?

Examine which countries and institutions are mostly involved in secondary PFAS research. Visualizing networks between these institutions.

### Basic summaries from bibliographic records

```{r basic bibliometric summaries}
results1 <- biblioAnalysis(bib_data) #run basic standard descriptive analysis of the dataset (data frame)
summary(results1, k = 10, pause = F, width = 130) #produces a sequence of standard summary tables displayed in the console
plot(x = results1, k = 10, pause = F) #produces a sequence of standard summary plots displayed in the plots window
#for individual plots assign the above to an object (p <- ) and then call individual plots (1-5, e.g. p[5])
#p <- plot(x = results1, k = 10, pause = F)
```

```{r table - counts by journal}

# Publication journals
knitr::kable(table(bib_data$JI), caption = "Table SX. counts of numbers of publications per journal")

```

### Making keyword co-occurrence matrix

```{r keyword co-occurance matrix, echo = FALSE}

#pdf(file="./plots/figure_keywords_network.pdf", width = 6, height = 5, pointsize = 12, family = "Helvetica", fonts = c("Helvetica"))
#par(mfrow=c(1,1), mar=c(2,4,2,4))
NetMatrix_keywords <- 
  biblioNetwork(bib_data, 
                analysis = "co-occurrences", 
                network = "keywords", 
                sep = ";")

NetMatrix_keywords_plot <- 
  networkPlot(NetMatrix_keywords,
              normalize="association", n = 15,
              Title = "Keyword co-occurrences", type = "fruchterman",
              size.cex = TRUE, size = 15,
              remove.multiple = F,
              edgesize = 4, 
              labelsize = 3, 
              label.cex = TRUE,
              edges.min = 2,
              label.n = 30, 
              alpha = 0.3) #adjust number and size of labels, as needed, etc.
#dev.off()

#str(NetMatrix_keywords_plot)
#res <- thematicMap(net, NetMatrix_keywords, S)
#plot(res$map)
```

### Co-word Analysis through Correspondence Analysis

```{r co-word analysis through correspondence analysis}
suppressWarnings(
conceptualStructure(bib_data,
                    method = "MCA",
                    field = "ID", 
                    minDegree = 15,
                    clust = 5,
                    stemming = FALSE,
                    labelsize = 15,
                    documents = 50)
)
```

### Thematic map based on keywords

```{r thematic map based on keywords}

#pdf(file="./plots/figure_thematic_map.pdf", width = 5, height = 5, pointsize = 8, family = "Helvetica", fonts = c("Helvetica"))
par(mfrow=c(1,1), mar=c(0,2,0,2))

map_thematic <- 
  thematicMap(bib_data, 
              field = "ID", 
              n = 1000, 
              minfreq = 5,  
              size = 0.5, 
              n.labels = 1, 
              repel = TRUE)

plot(map_thematic$map)
#dev.off()

```

### Author collaboration network

Links between review authors based on their co-authorship on these reviews. Currently, there are too few articles included for the connections between the clusters (publications) to be visible, although it looks like one set of authors co-authored two of the eight reviews from the pilot set.

```{r author collaboration network}

NetMatrix_authors <- 
  biblioNetwork(bib_data, analysis = "collaboration",  network = "authors", sep = ";")

NetMatrix_authors_plot <- 
  networkPlot(NetMatrix_authors,
              n = 50,
              Title = "Author collaboration", 
              type = "auto", 
              size = 2, 
              size.cex = TRUE, 
              edgesize = 10, 
              labelsize = 1.1) #note there are potentially some mistakes in authors initials

```

### Country collaboration network

Links between countries, based on the institutional affiliations of the review authors.

```{r country collaboration network 1}

#pdf(file="./plots/figure_country_collaboration_network.pdf",width = 4, height = 4, pointsize = 12, family = "Helvetica", fonts = c("Helvetica"))
#par(mfrow=c(1,1), mar=c(2,3,2,3))

bib_sco4 <-
  metaTagExtraction(bib_sco3,
                    Field = "AU_CO", 
                    sep = ";") #we need to extract countries from the affiliations first
#bib_sco2$AU_CO[1:10]

NetMatrix_country <- 
  biblioNetwork(bib_sco4, analysis = "collaboration", network = "countries", sep = ";")

NetMatrix_country_plot <- 
  networkPlot(NetMatrix_country,
              n = 15, 
              Title = "Country collaborations",
              type = "auto", 
              size.cex = TRUE,
              size= 15,
              remove.multiple=FALSE, 
              label.cex = TRUE,
              labelsize = 10,
              edgesize = 10)

#dev.off()

```

```{r country collaboration network 2}
NetMatrix_country_plot2 <- 
  networkPlot(NetMatrix_country,
              n = dim(NetMatrix_country)[1], 
              Title = "Country collaboration",
              type = "circle", 
              size = 10,
              size.cex = TRUE,
              remove.multiple = FALSE, 
              edgesize = 7,
              labelsize = 1.3,
              cluster = "none")

```

### Analyzing lists of references (cited works)

```{r bibliometrix test with refs, eval = TRUE, warning = FALSE}
 
# analyzing lists of references 
CR <- 
  citations(bib_sco, 
            field = "article", 
            sep = ";") #list of most cited articles

 cbind(CR$Cited[1:10]) #ten most cited articles
 
CR <- 
  citations(bib_sco, 
            field = "author",
            sep = ";")

cbind(CR$Cited[1:10]) #ten most cited authors
```

### Article (References) co-citation analysis

```{r bibliometrix co-citation network 1, eval = TRUE, warning = FALSE}

# classical article coupling network: Citation network
NetMatrix_cocitation <- 
  biblioNetwork(bib_sco, 
                analysis = "co-citation",
                network = "references", 
                sep = "; ")

NetMatrix_cocitation_plot <- 
  networkPlot(NetMatrix_cocitation, 
              n = 30, 
              Title = "Co-citation Network", 
              type = "fruchterman", 
              size.cex = TRUE ,
              size = 10, 
              remove.multiple = FALSE, 
              labelsize = 1,
              edgesize = 10) #plot the network

```

### Historical co-citation network

Currently not enough papers to create this network plot.

```{r bibliometrix co-citation network 2, eval = TRUE, warning = FALSE}

histResults <- 
  histNetwork(bib_sco, 
              sep = ";") 
# not possible now - Found 2 documents with no empty Local Citations (LCS)

# pdf(file="./plots/Figure_hstorical_network.pdf", width=8, height=8, pointsize=10)
# par(mfrow=c(1,1), mar=c(0,0,0,0))
histPlot(histResults, n=20, size = 5, labelsize = 4) 
# dev.off()

```

------------------------------------------------------------------------

## Cross-objective insights

We will investigate how review type, indicators of review quality or transparency are related other review properties, such as publication date, main review topic and subject, etc. Below, we provide a few examples where data belonging to different objectives is use together to answer these additional questions.

```{r simple plots review type vs Human_animal_environment}
# Review_type_claimed vs. Human_animal_environment contingency table
#table(mdata$Review_type_claimed) #needs cleaning
mdata$Review_type_claimed <- tolower(mdata$Review_type_claimed) 

t1 <- 
  mdata %>% 
  count(Human_animal_environment, Review_type_claimed)

# barplot of claimed review type vs. subject

ggplot(t1, aes(x = Review_type_claimed, y = n)) +
  labs(title = expression("Review type and subject")) + #~bold(A.)~' Type and subject'
  coord_flip()  +
  scale_fill_brewer() +
  geom_col(aes(fill = Human_animal_environment), width = 0.7) + 
  theme_light() +
  theme(legend.position = "bottom", 
        legend.box.background = element_rect(colour = "black"), 
        legend.title = element_blank(),  
        legend.text=element_text(size = 4), 
        axis.title.x = element_text(size = 10),
        axis.title.y = element_blank())

#ggsave(here("plots","figure_barplot_type_subject.pdf"), width = 4, height = 4, units = "cm", scale = 2, device = cairo_pdf)

```

```{r other simple plots, eval = FALSE}
## Code for other simple plots with two crossed variables (not run for pilot data)

# Barplot example Review_type_claimed vs. Human_animal_environment contingency table
t1 <- 
  mdata %>% 
  count(Human_animal_environment, Review_type_claimed)

ggplot(t1, aes(x = Human_animal_environment, y = n)) +
 coord_flip()  +
 theme(legend.position = "top") +
 geom_col(aes(fill = Review_type_claimed), width = 0.7)

ggplot(t1, aes(x = Review_type_claimed, y = n)) +
 coord_flip()  +
 theme(legend.position = "top") +
 geom_col(aes(fill = Human_animal_environment), width = 0.7)

# Heatmap example (it will look better with more data points)
t2 <- xtabs(~Review_type_claimed+Human_animal_environment, data = mdata)  #contingency table
#heatmap(t2, Colv = NA, Rowv = NA, scale="column", col=cm.colors(256), margins = c(15, 25)) #heatmap
heatmap(t2, Colv = NA, Rowv = NA, scale="column", col=heat.colors(12, rev=TRUE, alpha = 0.6), margins = c(15, 25)) #heatmap

#different vesion with side colour bars
#rc <- rainbow(nrow(t2), start = 0, end = .3)
#cc <- rainbow(ncol(t2), start = 0, end = .3)
#heatmap(t2, Colv = NA, Rowv = NA, scale="column", RowSideColors = rc, ColSideColors = cc, margins = c(15, 25)) #heatmap

```

# Tries

Subject & Reporting guidelines

```{r}
library(webr)
library(ggpubr)

colnames(mdata)[which(names(mdata) == "Human_animal_environment")] <- "Subject"

pd1 = mdata %>% 
  group_by(Subject, Reporting_guideline) %>% 
  drop_na(N_studies) %>% 
  summarise(n = sum(N_studies))

PieDonut1 <-  PieDonut(pd1,  aes(Subject, Reporting_guideline, count = n),
         labelposition = 0,
         r0 = 0.5,
         r1 = 0.95,
         title = "Reporting guidelines",
         titlesize = 5,
         pieLabelSize = 3,
         donutLabelSize = 2.5,
         explode = c(1,2),
         explodeDonut = TRUE
         )
```

Subject & COI statement

```{r}
pd2 = mdata %>% 
  group_by(Subject, COI_statement) %>% 
  drop_na(N_studies) %>% 
  summarise(n = sum(N_studies))

PieDonut2 <-  PieDonut(pd2,  aes(Subject, COI_statement, count = n),
         labelposition = 0,
         r0 = 0.5,
         r1 = 0.95,
         title = "COI statement",
         titlesize = 5,
         pieLabelSize = 3,
         donutLabelSize = 3,
         explode = c(1,2),
         explodeDonut=TRUE
         )
```

Subject & COI present

```{r}
pd3 = mdata %>% 
  group_by(Subject, COI_present) %>% 
  drop_na(N_studies, COI_present) %>% 
  filter(Subject != "Plants") %>% # Rremove plants subject
  summarise(n = sum(N_studies))

PieDonut3 <-  PieDonut(pd3,  aes(Subject, COI_present, count = n),
         labelposition = 0,
         r0 = 0.5,
         r1 = 0.95,
         title = "COI present",
         titlesize = 5,
         pieLabelSize = 3,
         donutLabelSize = 3
         )

(PieDonut2 | PieDonut3)

ggarrange(
  PieDonut2, PieDonut3, ncol = 2, nrow = 1
)
```

Subject & Funding statement

```{r}
pd4 = mdata %>% 
  group_by(Subject, Funding_statement) %>% 
  drop_na(N_studies) %>% 
  filter(Subject != "Plants") %>% # Rremove plants subject
  summarise(n = sum(N_studies))

PieDonut4 <-  PieDonut(pd4,  aes(Subject, Funding_statement, count = n),
         labelposition = 0,
         r0 = 0.5,
         r1 = 0.95,
         title = "Funding statement",
         titlesize = 5,
         pieLabelSize = 3,
         donutLabelSize = 3
         )
```

Subject & Industry funding

```{r}
pd5 = mdata %>% 
  group_by(Subject, Industry_funding) %>% 
  drop_na(N_studies, Industry_funding) %>% 
  filter(Subject != "Plants") %>% # Rremove plants subject
  summarise(n = sum(N_studies))

PieDonut5 <-  PieDonut(pd5,  aes(Subject, Industry_funding, count = n),
         labelposition = 0,
         r0 = 0.3,
         r1 = 0.93,
         title = "Industry funding",
         titlesize = 5,
         pieLabelSize = 3,
         donutLabelSize = 3
)
         
```
